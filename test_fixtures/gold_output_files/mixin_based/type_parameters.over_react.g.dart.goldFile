//@dart=2.11
// GENERATED CODE - DO NOT MODIFY BY HAND

// ignore_for_file: deprecated_member_use_from_same_package, unnecessary_null_in_if_null_operators, prefer_null_aware_operators, invalid_use_of_visible_for_overriding_member
part of 'type_parameters.dart';

// **************************************************************************
// OverReactBuilder (package:over_react/src/builder.dart)
// **************************************************************************

@Deprecated('This API is for use only within generated code.'
    ' Do not reference it in your code, as it may change at any time.'
    ' EXCEPTION: this may be used in legacy boilerplate until'
    ' it is transitioned to the new mixin-based boilerplate.')
mixin $NoneProps on NoneProps {
  static const PropsMeta meta = _$metaForNoneProps;
  /* GENERATED CONSTANTS */

  static const List<PropDescriptor> $props = [];
  static const List<String> $propKeys = [];

  @override
  @UiProps.$mustCallSuper
  void validateRequiredProps() {
    super.validateRequiredProps();
  }
}

@Deprecated('This API is for use only within generated code.'
    ' Do not reference it in your code, as it may change at any time.')
const PropsMeta _$metaForNoneProps = PropsMeta(
  fields: $NoneProps.$props,
  keys: $NoneProps.$propKeys,
);

@Deprecated('This API is for use only within generated code.'
    ' Do not reference it in your code, as it may change at any time.'
    ' EXCEPTION: this may be used in legacy boilerplate until'
    ' it is transitioned to the new mixin-based boilerplate.')
mixin $SingleProps<T> on SingleProps<T> {
  static const PropsMeta meta = _$metaForSingleProps;
  @override
  T get single => (props[_$key__single__SingleProps] ?? null) as T;
  @override
  set single(T value) => props[_$key__single__SingleProps] = value;
  /* GENERATED CONSTANTS */
  static const PropDescriptor _$prop__single__SingleProps =
      PropDescriptor(_$key__single__SingleProps);
  static const String _$key__single__SingleProps = 'SingleProps.single';

  static const List<PropDescriptor> $props = [_$prop__single__SingleProps];
  static const List<String> $propKeys = [_$key__single__SingleProps];

  @override
  @UiProps.$mustCallSuper
  void validateRequiredProps() {
    super.validateRequiredProps();
  }
}

@Deprecated('This API is for use only within generated code.'
    ' Do not reference it in your code, as it may change at any time.')
const PropsMeta _$metaForSingleProps = PropsMeta(
  fields: $SingleProps.$props,
  keys: $SingleProps.$propKeys,
);

@Deprecated('This API is for use only within generated code.'
    ' Do not reference it in your code, as it may change at any time.'
    ' EXCEPTION: this may be used in legacy boilerplate until'
    ' it is transitioned to the new mixin-based boilerplate.')
mixin $SingleThatWontBeSpecifiedProps<T> on SingleThatWontBeSpecifiedProps<T> {
  static const PropsMeta meta = _$metaForSingleThatWontBeSpecifiedProps;
  @override
  T get singleThatWontBeSpecified => (props[
          _$key__singleThatWontBeSpecified__SingleThatWontBeSpecifiedProps] ??
      null) as T;
  @override
  set singleThatWontBeSpecified(T value) =>
      props[_$key__singleThatWontBeSpecified__SingleThatWontBeSpecifiedProps] =
          value;
  /* GENERATED CONSTANTS */
  static const PropDescriptor
      _$prop__singleThatWontBeSpecified__SingleThatWontBeSpecifiedProps =
      PropDescriptor(
          _$key__singleThatWontBeSpecified__SingleThatWontBeSpecifiedProps);
  static const String
      _$key__singleThatWontBeSpecified__SingleThatWontBeSpecifiedProps =
      'SingleThatWontBeSpecifiedProps.singleThatWontBeSpecified';

  static const List<PropDescriptor> $props = [
    _$prop__singleThatWontBeSpecified__SingleThatWontBeSpecifiedProps
  ];
  static const List<String> $propKeys = [
    _$key__singleThatWontBeSpecified__SingleThatWontBeSpecifiedProps
  ];

  @override
  @UiProps.$mustCallSuper
  void validateRequiredProps() {
    super.validateRequiredProps();
  }
}

@Deprecated('This API is for use only within generated code.'
    ' Do not reference it in your code, as it may change at any time.')
const PropsMeta _$metaForSingleThatWontBeSpecifiedProps = PropsMeta(
  fields: $SingleThatWontBeSpecifiedProps.$props,
  keys: $SingleThatWontBeSpecifiedProps.$propKeys,
);

@Deprecated('This API is for use only within generated code.'
    ' Do not reference it in your code, as it may change at any time.'
    ' EXCEPTION: this may be used in legacy boilerplate until'
    ' it is transitioned to the new mixin-based boilerplate.')
mixin $SingleWithBoundProps<S extends Pattern> on SingleWithBoundProps<S> {
  static const PropsMeta meta = _$metaForSingleWithBoundProps;
  @override
  S get singleWithBound =>
      (props[_$key__singleWithBound__SingleWithBoundProps] ?? null) as S;
  @override
  set singleWithBound(S value) =>
      props[_$key__singleWithBound__SingleWithBoundProps] = value;
  /* GENERATED CONSTANTS */
  static const PropDescriptor _$prop__singleWithBound__SingleWithBoundProps =
      PropDescriptor(_$key__singleWithBound__SingleWithBoundProps);
  static const String _$key__singleWithBound__SingleWithBoundProps =
      'SingleWithBoundProps.singleWithBound';

  static const List<PropDescriptor> $props = [
    _$prop__singleWithBound__SingleWithBoundProps
  ];
  static const List<String> $propKeys = [
    _$key__singleWithBound__SingleWithBoundProps
  ];

  @override
  @UiProps.$mustCallSuper
  void validateRequiredProps() {
    super.validateRequiredProps();
  }
}

@Deprecated('This API is for use only within generated code.'
    ' Do not reference it in your code, as it may change at any time.')
const PropsMeta _$metaForSingleWithBoundProps = PropsMeta(
  fields: $SingleWithBoundProps.$props,
  keys: $SingleWithBoundProps.$propKeys,
);

@Deprecated('This API is for use only within generated code.'
    ' Do not reference it in your code, as it may change at any time.'
    ' EXCEPTION: this may be used in legacy boilerplate until'
    ' it is transitioned to the new mixin-based boilerplate.')
mixin $DoubleProps<A, B> on DoubleProps<A, B> {
  static const PropsMeta meta = _$metaForDoubleProps;
  @override
  A get doubleA => (props[_$key__doubleA__DoubleProps] ?? null) as A;
  @override
  set doubleA(A value) => props[_$key__doubleA__DoubleProps] = value;
  @override
  B get doubleB => (props[_$key__doubleB__DoubleProps] ?? null) as B;
  @override
  set doubleB(B value) => props[_$key__doubleB__DoubleProps] = value;
  /* GENERATED CONSTANTS */
  static const PropDescriptor _$prop__doubleA__DoubleProps =
      PropDescriptor(_$key__doubleA__DoubleProps);
  static const PropDescriptor _$prop__doubleB__DoubleProps =
      PropDescriptor(_$key__doubleB__DoubleProps);
  static const String _$key__doubleA__DoubleProps = 'DoubleProps.doubleA';
  static const String _$key__doubleB__DoubleProps = 'DoubleProps.doubleB';

  static const List<PropDescriptor> $props = [
    _$prop__doubleA__DoubleProps,
    _$prop__doubleB__DoubleProps
  ];
  static const List<String> $propKeys = [
    _$key__doubleA__DoubleProps,
    _$key__doubleB__DoubleProps
  ];

  @override
  @UiProps.$mustCallSuper
  void validateRequiredProps() {
    super.validateRequiredProps();
  }
}

@Deprecated('This API is for use only within generated code.'
    ' Do not reference it in your code, as it may change at any time.')
const PropsMeta _$metaForDoubleProps = PropsMeta(
  fields: $DoubleProps.$props,
  keys: $DoubleProps.$propKeys,
);

_$$SingleProps _$Single([Map backingProps]) => _$$SingleProps(backingProps);

// Concrete props implementation.
//
// Implements constructor and backing map, and links up to generated component factory.
@Deprecated('This API is for use only within generated code.'
    ' Do not reference it in your code, as it may change at any time.')
class _$$SingleProps<T> extends UiProps
    with
        SingleProps<T>,
        // If this generated mixin is undefined, it's likely because SingleProps is not a valid `mixin`-based props mixin, or because it is but the generated mixin was not imported. Check the declaration of SingleProps, and check that $SingleProps is exported/imported properly.
        $SingleProps<T> {
  _$$SingleProps([Map backingMap]) : this.props = backingMap ?? JsBackedMap();

  /// The backing props map proxied by this class.
  @override
  final Map props;

  /// Let `UiProps` internals know that this class has been generated.
  @override
  bool get $isClassGenerated => true;

  /// The default namespace for the prop getters/setters generated for this class.
  @override
  String get propKeyNamespace => '';

  @override
  PropsMetaCollection get staticMeta => const PropsMetaCollection({
        // If this generated mixin is undefined, it's likely because SingleProps is not a valid `mixin`-based props mixin, or because it is but the generated mixin was not imported. Check the declaration of SingleProps, and check that $SingleProps is exported/imported properly.
        SingleProps: $SingleProps.meta,
      });

  @override
  String $getPropKey(void Function(Map m) accessMap) =>
      _$getPropKey$_$$SingleProps(accessMap, (map) => _$$SingleProps(map));

  @override
  // ignore: must_call_super
  validateRequiredProps() {
    // Disable required prop validation, until this component is null safe, by not calling super.
  }
}

/// An alias for [getPropKey] so it can be referenced within the props class impl
/// without being shadowed by the `getPropKey` instance extension member.
const _$getPropKey$_$$SingleProps = getPropKey;
_$$SingleWithBoundProps _$SingleWithBound([Map backingProps]) =>
    _$$SingleWithBoundProps(backingProps);

// Concrete props implementation.
//
// Implements constructor and backing map, and links up to generated component factory.
@Deprecated('This API is for use only within generated code.'
    ' Do not reference it in your code, as it may change at any time.')
class _$$SingleWithBoundProps<S extends Pattern> extends UiProps
    with
        SingleWithBoundProps<S>,
        // If this generated mixin is undefined, it's likely because SingleWithBoundProps is not a valid `mixin`-based props mixin, or because it is but the generated mixin was not imported. Check the declaration of SingleWithBoundProps, and check that $SingleWithBoundProps is exported/imported properly.
        $SingleWithBoundProps<S> {
  _$$SingleWithBoundProps([Map backingMap])
      : this.props = backingMap ?? JsBackedMap();

  /// The backing props map proxied by this class.
  @override
  final Map props;

  /// Let `UiProps` internals know that this class has been generated.
  @override
  bool get $isClassGenerated => true;

  /// The default namespace for the prop getters/setters generated for this class.
  @override
  String get propKeyNamespace => '';

  @override
  PropsMetaCollection get staticMeta => const PropsMetaCollection({
        // If this generated mixin is undefined, it's likely because SingleWithBoundProps is not a valid `mixin`-based props mixin, or because it is but the generated mixin was not imported. Check the declaration of SingleWithBoundProps, and check that $SingleWithBoundProps is exported/imported properly.
        SingleWithBoundProps: $SingleWithBoundProps.meta,
      });

  @override
  String $getPropKey(void Function(Map m) accessMap) =>
      _$getPropKey$_$$SingleWithBoundProps(
          accessMap, (map) => _$$SingleWithBoundProps(map));

  @override
  // ignore: must_call_super
  validateRequiredProps() {
    // Disable required prop validation, until this component is null safe, by not calling super.
  }
}

/// An alias for [getPropKey] so it can be referenced within the props class impl
/// without being shadowed by the `getPropKey` instance extension member.
const _$getPropKey$_$$SingleWithBoundProps = getPropKey;
_$$DoubleProps _$Double([Map backingProps]) => _$$DoubleProps(backingProps);

// Concrete props implementation.
//
// Implements constructor and backing map, and links up to generated component factory.
@Deprecated('This API is for use only within generated code.'
    ' Do not reference it in your code, as it may change at any time.')
class _$$DoubleProps<A, B> extends UiProps
    with
        DoubleProps<A, B>,
        // If this generated mixin is undefined, it's likely because DoubleProps is not a valid `mixin`-based props mixin, or because it is but the generated mixin was not imported. Check the declaration of DoubleProps, and check that $DoubleProps is exported/imported properly.
        $DoubleProps<A, B> {
  _$$DoubleProps([Map backingMap]) : this.props = backingMap ?? JsBackedMap();

  /// The backing props map proxied by this class.
  @override
  final Map props;

  /// Let `UiProps` internals know that this class has been generated.
  @override
  bool get $isClassGenerated => true;

  /// The default namespace for the prop getters/setters generated for this class.
  @override
  String get propKeyNamespace => '';

  @override
  PropsMetaCollection get staticMeta => const PropsMetaCollection({
        // If this generated mixin is undefined, it's likely because DoubleProps is not a valid `mixin`-based props mixin, or because it is but the generated mixin was not imported. Check the declaration of DoubleProps, and check that $DoubleProps is exported/imported properly.
        DoubleProps: $DoubleProps.meta,
      });

  @override
  String $getPropKey(void Function(Map m) accessMap) =>
      _$getPropKey$_$$DoubleProps(accessMap, (map) => _$$DoubleProps(map));

  @override
  // ignore: must_call_super
  validateRequiredProps() {
    // Disable required prop validation, until this component is null safe, by not calling super.
  }
}

/// An alias for [getPropKey] so it can be referenced within the props class impl
/// without being shadowed by the `getPropKey` instance extension member.
const _$getPropKey$_$$DoubleProps = getPropKey;
_$$ConcreteNoneProps _$ConcreteNone([Map backingProps]) =>
    _$$ConcreteNoneProps(backingProps);

// Concrete props implementation.
//
// Implements constructor and backing map, and links up to generated component factory.
@Deprecated('This API is for use only within generated code.'
    ' Do not reference it in your code, as it may change at any time.')
class _$$ConcreteNoneProps extends UiProps
    with
        NoneProps,
        // If this generated mixin is undefined, it's likely because NoneProps is not a valid `mixin`-based props mixin, or because it is but the generated mixin was not imported. Check the declaration of NoneProps, and check that $NoneProps is exported/imported properly.
        $NoneProps,
        SingleProps<String>,
        // If this generated mixin is undefined, it's likely because SingleProps is not a valid `mixin`-based props mixin, or because it is but the generated mixin was not imported. Check the declaration of SingleProps, and check that $SingleProps is exported/imported properly.
        $SingleProps<String>,
        SingleThatWontBeSpecifiedProps,
        // If this generated mixin is undefined, it's likely because SingleThatWontBeSpecifiedProps is not a valid `mixin`-based props mixin, or because it is but the generated mixin was not imported. Check the declaration of SingleThatWontBeSpecifiedProps, and check that $SingleThatWontBeSpecifiedProps is exported/imported properly.
        $SingleThatWontBeSpecifiedProps,
        SingleWithBoundProps<RegExp>,
        // If this generated mixin is undefined, it's likely because SingleWithBoundProps is not a valid `mixin`-based props mixin, or because it is but the generated mixin was not imported. Check the declaration of SingleWithBoundProps, and check that $SingleWithBoundProps is exported/imported properly.
        $SingleWithBoundProps<RegExp>,
        DoubleProps<double, int>,
        // If this generated mixin is undefined, it's likely because DoubleProps is not a valid `mixin`-based props mixin, or because it is but the generated mixin was not imported. Check the declaration of DoubleProps, and check that $DoubleProps is exported/imported properly.
        $DoubleProps<double, int>
    implements
        ConcreteNoneProps {
  _$$ConcreteNoneProps([Map backingMap])
      : this.props = backingMap ?? JsBackedMap();

  /// The backing props map proxied by this class.
  @override
  final Map props;

  /// Let `UiProps` internals know that this class has been generated.
  @override
  bool get $isClassGenerated => true;

  /// The default namespace for the prop getters/setters generated for this class.
  @override
  String get propKeyNamespace => '';

  @override
  PropsMetaCollection get staticMeta => const PropsMetaCollection({
        // If this generated mixin is undefined, it's likely because NoneProps is not a valid `mixin`-based props mixin, or because it is but the generated mixin was not imported. Check the declaration of NoneProps, and check that $NoneProps is exported/imported properly.
        NoneProps: $NoneProps.meta,
        // If this generated mixin is undefined, it's likely because SingleProps is not a valid `mixin`-based props mixin, or because it is but the generated mixin was not imported. Check the declaration of SingleProps, and check that $SingleProps is exported/imported properly.
        SingleProps: $SingleProps.meta,
        // If this generated mixin is undefined, it's likely because SingleThatWontBeSpecifiedProps is not a valid `mixin`-based props mixin, or because it is but the generated mixin was not imported. Check the declaration of SingleThatWontBeSpecifiedProps, and check that $SingleThatWontBeSpecifiedProps is exported/imported properly.
        SingleThatWontBeSpecifiedProps: $SingleThatWontBeSpecifiedProps.meta,
        // If this generated mixin is undefined, it's likely because SingleWithBoundProps is not a valid `mixin`-based props mixin, or because it is but the generated mixin was not imported. Check the declaration of SingleWithBoundProps, and check that $SingleWithBoundProps is exported/imported properly.
        SingleWithBoundProps: $SingleWithBoundProps.meta,
        // If this generated mixin is undefined, it's likely because DoubleProps is not a valid `mixin`-based props mixin, or because it is but the generated mixin was not imported. Check the declaration of DoubleProps, and check that $DoubleProps is exported/imported properly.
        DoubleProps: $DoubleProps.meta,
      });

  @override
  String $getPropKey(void Function(Map m) accessMap) =>
      _$getPropKey$_$$ConcreteNoneProps(
          accessMap, (map) => _$$ConcreteNoneProps(map));

  @override
  // ignore: must_call_super
  validateRequiredProps() {
    // Disable required prop validation, until this component is null safe, by not calling super.
  }
}

/// An alias for [getPropKey] so it can be referenced within the props class impl
/// without being shadowed by the `getPropKey` instance extension member.
const _$getPropKey$_$$ConcreteNoneProps = getPropKey;
_$$ConcreteArgsProps _$ConcreteArgs([Map backingProps]) =>
    _$$ConcreteArgsProps(backingProps);

// Concrete props implementation.
//
// Implements constructor and backing map, and links up to generated component factory.
@Deprecated('This API is for use only within generated code.'
    ' Do not reference it in your code, as it may change at any time.')
class _$$ConcreteArgsProps<U, V extends Iterable> extends UiProps
    with
        NoneProps,
        // If this generated mixin is undefined, it's likely because NoneProps is not a valid `mixin`-based props mixin, or because it is but the generated mixin was not imported. Check the declaration of NoneProps, and check that $NoneProps is exported/imported properly.
        $NoneProps,
        SingleProps<String>,
        // If this generated mixin is undefined, it's likely because SingleProps is not a valid `mixin`-based props mixin, or because it is but the generated mixin was not imported. Check the declaration of SingleProps, and check that $SingleProps is exported/imported properly.
        $SingleProps<String>,
        SingleThatWontBeSpecifiedProps,
        // If this generated mixin is undefined, it's likely because SingleThatWontBeSpecifiedProps is not a valid `mixin`-based props mixin, or because it is but the generated mixin was not imported. Check the declaration of SingleThatWontBeSpecifiedProps, and check that $SingleThatWontBeSpecifiedProps is exported/imported properly.
        $SingleThatWontBeSpecifiedProps,
        SingleWithBoundProps<RegExp>,
        // If this generated mixin is undefined, it's likely because SingleWithBoundProps is not a valid `mixin`-based props mixin, or because it is but the generated mixin was not imported. Check the declaration of SingleWithBoundProps, and check that $SingleWithBoundProps is exported/imported properly.
        $SingleWithBoundProps<RegExp>,
        DoubleProps<U, V>,
        // If this generated mixin is undefined, it's likely because DoubleProps is not a valid `mixin`-based props mixin, or because it is but the generated mixin was not imported. Check the declaration of DoubleProps, and check that $DoubleProps is exported/imported properly.
        $DoubleProps<U, V>
    implements
        ConcreteArgsProps<U, V> {
  _$$ConcreteArgsProps([Map backingMap])
      : this.props = backingMap ?? JsBackedMap();

  /// The backing props map proxied by this class.
  @override
  final Map props;

  /// Let `UiProps` internals know that this class has been generated.
  @override
  bool get $isClassGenerated => true;

  /// The default namespace for the prop getters/setters generated for this class.
  @override
  String get propKeyNamespace => '';

  @override
  PropsMetaCollection get staticMeta => const PropsMetaCollection({
        // If this generated mixin is undefined, it's likely because NoneProps is not a valid `mixin`-based props mixin, or because it is but the generated mixin was not imported. Check the declaration of NoneProps, and check that $NoneProps is exported/imported properly.
        NoneProps: $NoneProps.meta,
        // If this generated mixin is undefined, it's likely because SingleProps is not a valid `mixin`-based props mixin, or because it is but the generated mixin was not imported. Check the declaration of SingleProps, and check that $SingleProps is exported/imported properly.
        SingleProps: $SingleProps.meta,
        // If this generated mixin is undefined, it's likely because SingleThatWontBeSpecifiedProps is not a valid `mixin`-based props mixin, or because it is but the generated mixin was not imported. Check the declaration of SingleThatWontBeSpecifiedProps, and check that $SingleThatWontBeSpecifiedProps is exported/imported properly.
        SingleThatWontBeSpecifiedProps: $SingleThatWontBeSpecifiedProps.meta,
        // If this generated mixin is undefined, it's likely because SingleWithBoundProps is not a valid `mixin`-based props mixin, or because it is but the generated mixin was not imported. Check the declaration of SingleWithBoundProps, and check that $SingleWithBoundProps is exported/imported properly.
        SingleWithBoundProps: $SingleWithBoundProps.meta,
        // If this generated mixin is undefined, it's likely because DoubleProps is not a valid `mixin`-based props mixin, or because it is but the generated mixin was not imported. Check the declaration of DoubleProps, and check that $DoubleProps is exported/imported properly.
        DoubleProps: $DoubleProps.meta,
      });

  @override
  String $getPropKey(void Function(Map m) accessMap) =>
      _$getPropKey$_$$ConcreteArgsProps(
          accessMap, (map) => _$$ConcreteArgsProps(map));

  @override
  // ignore: must_call_super
  validateRequiredProps() {
    // Disable required prop validation, until this component is null safe, by not calling super.
  }
}

/// An alias for [getPropKey] so it can be referenced within the props class impl
/// without being shadowed by the `getPropKey` instance extension member.
const _$getPropKey$_$$ConcreteArgsProps = getPropKey;
