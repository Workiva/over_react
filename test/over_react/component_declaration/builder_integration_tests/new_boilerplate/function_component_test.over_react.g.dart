// GENERATED CODE - DO NOT MODIFY BY HAND

// ignore_for_file: deprecated_member_use_from_same_package, unnecessary_null_in_if_null_operators, prefer_null_aware_operators
part of 'function_component_test.dart';

// **************************************************************************
// OverReactBuilder (package:over_react/src/builder.dart)
// **************************************************************************

@Deprecated('This API is for use only within generated code.'
    ' Do not reference it in your code, as it may change at any time.'
    ' EXCEPTION: this may be used in legacy boilerplate until'
    ' it is transitioned to the new mixin-based boilerplate.')
mixin $TestPropsMixin on TestPropsMixin {
  static const PropsMeta meta = _$metaForTestPropsMixin;
  @override
  String get stringProp =>
      (props[_$key__stringProp__TestPropsMixin] ?? null) as String;
  @override
  set stringProp(String value) =>
      props[_$key__stringProp__TestPropsMixin] = value;
  @override
  dynamic get dynamicProp =>
      (props[_$key__dynamicProp__TestPropsMixin] ?? null) as dynamic;
  @override
  set dynamicProp(dynamic value) =>
      props[_$key__dynamicProp__TestPropsMixin] = value;
  @override
  get untypedProp => props[_$key__untypedProp__TestPropsMixin] ?? null;
  @override
  set untypedProp(value) => props[_$key__untypedProp__TestPropsMixin] = value;
  @override
  @Accessor(key: 'custom key!')
  dynamic get customKeyProp =>
      (props[_$key__customKeyProp__TestPropsMixin] ?? null) as dynamic;
  @override
  @Accessor(key: 'custom key!')
  set customKeyProp(dynamic value) =>
      props[_$key__customKeyProp__TestPropsMixin] = value;
  @override
  @Accessor(keyNamespace: 'custom namespace~~')
  dynamic get customNamespaceProp =>
      (props[_$key__customNamespaceProp__TestPropsMixin] ?? null) as dynamic;
  @override
  @Accessor(keyNamespace: 'custom namespace~~')
  set customNamespaceProp(dynamic value) =>
      props[_$key__customNamespaceProp__TestPropsMixin] = value;
  @override
  @Accessor(keyNamespace: 'custom namespace~~', key: 'custom key!')
  dynamic get customKeyAndNamespaceProp =>
      (props[_$key__customKeyAndNamespaceProp__TestPropsMixin] ?? null)
          as dynamic;
  @override
  @Accessor(keyNamespace: 'custom namespace~~', key: 'custom key!')
  set customKeyAndNamespaceProp(dynamic value) =>
      props[_$key__customKeyAndNamespaceProp__TestPropsMixin] = value;
  /* GENERATED CONSTANTS */
  static const PropDescriptor _$prop__stringProp__TestPropsMixin =
      PropDescriptor(_$key__stringProp__TestPropsMixin);
  static const PropDescriptor _$prop__dynamicProp__TestPropsMixin =
      PropDescriptor(_$key__dynamicProp__TestPropsMixin);
  static const PropDescriptor _$prop__untypedProp__TestPropsMixin =
      PropDescriptor(_$key__untypedProp__TestPropsMixin);
  static const PropDescriptor _$prop__customKeyProp__TestPropsMixin =
      PropDescriptor(_$key__customKeyProp__TestPropsMixin);
  static const PropDescriptor _$prop__customNamespaceProp__TestPropsMixin =
      PropDescriptor(_$key__customNamespaceProp__TestPropsMixin);
  static const PropDescriptor
      _$prop__customKeyAndNamespaceProp__TestPropsMixin =
      PropDescriptor(_$key__customKeyAndNamespaceProp__TestPropsMixin);
  static const String _$key__stringProp__TestPropsMixin =
      'TestPropsMixin.stringProp';
  static const String _$key__dynamicProp__TestPropsMixin =
      'TestPropsMixin.dynamicProp';
  static const String _$key__untypedProp__TestPropsMixin =
      'TestPropsMixin.untypedProp';
  static const String _$key__customKeyProp__TestPropsMixin =
      'TestPropsMixin.custom key!';
  static const String _$key__customNamespaceProp__TestPropsMixin =
      'custom namespace~~customNamespaceProp';
  static const String _$key__customKeyAndNamespaceProp__TestPropsMixin =
      'custom namespace~~custom key!';

  static const List<PropDescriptor> $props = [
    _$prop__stringProp__TestPropsMixin,
    _$prop__dynamicProp__TestPropsMixin,
    _$prop__untypedProp__TestPropsMixin,
    _$prop__customKeyProp__TestPropsMixin,
    _$prop__customNamespaceProp__TestPropsMixin,
    _$prop__customKeyAndNamespaceProp__TestPropsMixin
  ];
  static const List<String> $propKeys = [
    _$key__stringProp__TestPropsMixin,
    _$key__dynamicProp__TestPropsMixin,
    _$key__untypedProp__TestPropsMixin,
    _$key__customKeyProp__TestPropsMixin,
    _$key__customNamespaceProp__TestPropsMixin,
    _$key__customKeyAndNamespaceProp__TestPropsMixin
  ];
}

@Deprecated('This API is for use only within generated code.'
    ' Do not reference it in your code, as it may change at any time.')
const PropsMeta _$metaForTestPropsMixin = PropsMeta(
  fields: $TestPropsMixin.$props,
  keys: $TestPropsMixin.$propKeys,
);

@Deprecated('This API is for use only within generated code.'
    ' Do not reference it in your code, as it may change at any time.'
    ' EXCEPTION: this may be used in legacy boilerplate until'
    ' it is transitioned to the new mixin-based boilerplate.')
mixin $ASecondPropsMixin on ASecondPropsMixin {
  static const PropsMeta meta = _$metaForASecondPropsMixin;
  @override
  String get anotherProp =>
      (props[_$key__anotherProp__ASecondPropsMixin] ?? null) as String;
  @override
  set anotherProp(String value) =>
      props[_$key__anotherProp__ASecondPropsMixin] = value;
  /* GENERATED CONSTANTS */
  static const PropDescriptor _$prop__anotherProp__ASecondPropsMixin =
      PropDescriptor(_$key__anotherProp__ASecondPropsMixin);
  static const String _$key__anotherProp__ASecondPropsMixin =
      'ASecondPropsMixin.anotherProp';

  static const List<PropDescriptor> $props = [
    _$prop__anotherProp__ASecondPropsMixin
  ];
  static const List<String> $propKeys = [_$key__anotherProp__ASecondPropsMixin];
}

@Deprecated('This API is for use only within generated code.'
    ' Do not reference it in your code, as it may change at any time.')
const PropsMeta _$metaForASecondPropsMixin = PropsMeta(
  fields: $ASecondPropsMixin.$props,
  keys: $ASecondPropsMixin.$propKeys,
);

@Deprecated('This API is for use only within generated code.'
    ' Do not reference it in your code, as it may change at any time.'
    ' EXCEPTION: this may be used in legacy boilerplate until'
    ' it is transitioned to the new mixin-based boilerplate.')
mixin $AThirdPropsMixin on AThirdPropsMixin {
  static const PropsMeta meta = _$metaForAThirdPropsMixin;
  @override
  String get aPropsFromAThirdMixin =>
      (props[_$key__aPropsFromAThirdMixin__AThirdPropsMixin] ?? null) as String;
  @override
  set aPropsFromAThirdMixin(String value) =>
      props[_$key__aPropsFromAThirdMixin__AThirdPropsMixin] = value;
  /* GENERATED CONSTANTS */
  static const PropDescriptor _$prop__aPropsFromAThirdMixin__AThirdPropsMixin =
      PropDescriptor(_$key__aPropsFromAThirdMixin__AThirdPropsMixin);
  static const String _$key__aPropsFromAThirdMixin__AThirdPropsMixin =
      'AThirdPropsMixin.aPropsFromAThirdMixin';

  static const List<PropDescriptor> $props = [
    _$prop__aPropsFromAThirdMixin__AThirdPropsMixin
  ];
  static const List<String> $propKeys = [
    _$key__aPropsFromAThirdMixin__AThirdPropsMixin
  ];
}

@Deprecated('This API is for use only within generated code.'
    ' Do not reference it in your code, as it may change at any time.')
const PropsMeta _$metaForAThirdPropsMixin = PropsMeta(
  fields: $AThirdPropsMixin.$props,
  keys: $AThirdPropsMixin.$propKeys,
);

final UiFactoryConfig<_$$TestProps> _$TestConfig = UiFactoryConfig(
    propsFactory: PropsFactory(
      map: (map) => _$$TestProps(map),
      jsMap: (map) => _$$TestProps$JsMap(map),
    ),
    displayName: 'Test');

@Deprecated(r'Use the private variable, _$TestConfig, instead '
    'and update the `over_react` lower bound to version 4.1.0. '
    'For information on why this is deprecated, see https://github.com/Workiva/over_react/pull/650')
final UiFactoryConfig<_$$TestProps> $TestConfig = _$TestConfig;

final UiFactoryConfig<_$$TestProps> _$TestPublicConfig = UiFactoryConfig(
    propsFactory: PropsFactory(
      map: (map) => _$$TestProps(map),
      jsMap: (map) => _$$TestProps$JsMap(map),
    ),
    displayName: 'TestPublic');

@Deprecated(r'Use the private variable, _$TestPublicConfig, instead '
    'and update the `over_react` lower bound to version 4.1.0. '
    'For information on why this is deprecated, see https://github.com/Workiva/over_react/pull/650')
final UiFactoryConfig<_$$TestProps> $TestPublicConfig = _$TestPublicConfig;

final UiFactoryConfig<_$$TestProps> _$NoLHSTestConfig = UiFactoryConfig(
    propsFactory: PropsFactory(
      map: (map) => _$$TestProps(map),
      jsMap: (map) => _$$TestProps$JsMap(map),
    ),
    displayName: 'NoLHSTest');

@Deprecated(r'Use the private variable, _$NoLHSTestConfig, instead '
    'and update the `over_react` lower bound to version 4.1.0. '
    'For information on why this is deprecated, see https://github.com/Workiva/over_react/pull/650')
final UiFactoryConfig<_$$TestProps> $NoLHSTestConfig = _$NoLHSTestConfig;

final UiFactoryConfig<_$$TestProps> _$_TestConfig = UiFactoryConfig(
    propsFactory: PropsFactory(
      map: (map) => _$$TestProps(map),
      jsMap: (map) => _$$TestProps$JsMap(map),
    ),
    displayName: '_Test');

@Deprecated(r'Use the private variable, _$_TestConfig, instead '
    'and update the `over_react` lower bound to version 4.1.0. '
    'For information on why this is deprecated, see https://github.com/Workiva/over_react/pull/650')
final UiFactoryConfig<_$$TestProps> $_TestConfig = _$_TestConfig;

// Concrete props implementation.
//
// Implements constructor and backing map, and links up to generated component factory.
@Deprecated('This API is for use only within generated code.'
    ' Do not reference it in your code, as it may change at any time.')
abstract class _$$TestProps extends UiProps
    with
        TestPropsMixin,
        $TestPropsMixin, // If this generated mixin is undefined, it's likely because TestPropsMixin is not a valid `mixin`-based props mixin, or because it is but the generated mixin was not imported. Check the declaration of TestPropsMixin, and check that $TestPropsMixin is exported/imported properly.
        ASecondPropsMixin,
        $ASecondPropsMixin, // If this generated mixin is undefined, it's likely because ASecondPropsMixin is not a valid `mixin`-based props mixin, or because it is but the generated mixin was not imported. Check the declaration of ASecondPropsMixin, and check that $ASecondPropsMixin is exported/imported properly.
        AThirdPropsMixin,
        $AThirdPropsMixin // If this generated mixin is undefined, it's likely because AThirdPropsMixin is not a valid `mixin`-based props mixin, or because it is but the generated mixin was not imported. Check the declaration of AThirdPropsMixin, and check that $AThirdPropsMixin is exported/imported properly.
    implements
        TestProps {
  _$$TestProps._();

  factory _$$TestProps(Map backingMap) {
    if (backingMap == null || backingMap is JsBackedMap) {
      return _$$TestProps$JsMap(backingMap as JsBackedMap);
    } else {
      return _$$TestProps$PlainMap(backingMap);
    }
  }

  /// Let `UiProps` internals know that this class has been generated.
  @override
  bool get $isClassGenerated => true;

  /// The default namespace for the prop getters/setters generated for this class.
  @override
  String get propKeyNamespace => '';

  @override
  PropsMetaCollection get staticMeta => const PropsMetaCollection({
        // If this generated mixin is undefined, it's likely because TestPropsMixin is not a valid `mixin`-based props mixin, or because it is but the generated mixin was not imported. Check the declaration of TestPropsMixin, and check that $TestPropsMixin is exported/imported properly.
        TestPropsMixin: $TestPropsMixin.meta,
        // If this generated mixin is undefined, it's likely because ASecondPropsMixin is not a valid `mixin`-based props mixin, or because it is but the generated mixin was not imported. Check the declaration of ASecondPropsMixin, and check that $ASecondPropsMixin is exported/imported properly.
        ASecondPropsMixin: $ASecondPropsMixin.meta,
        // If this generated mixin is undefined, it's likely because AThirdPropsMixin is not a valid `mixin`-based props mixin, or because it is but the generated mixin was not imported. Check the declaration of AThirdPropsMixin, and check that $AThirdPropsMixin is exported/imported properly.
        AThirdPropsMixin: $AThirdPropsMixin.meta,
      });
}

// Concrete props implementation that can be backed by any [Map].
@Deprecated('This API is for use only within generated code.'
    ' Do not reference it in your code, as it may change at any time.')
class _$$TestProps$PlainMap extends _$$TestProps {
  // This initializer of `_props` to an empty map, as well as the reassignment
  // of `_props` in the constructor body is necessary to work around a DDC bug: https://github.com/dart-lang/sdk/issues/36217
  _$$TestProps$PlainMap(Map backingMap)
      : this._props = {},
        super._() {
    this._props = backingMap ?? {};
  }

  /// The backing props map proxied by this class.
  @override
  Map get props => _props;
  Map _props;
}

// Concrete props implementation that can only be backed by [JsMap],
// allowing dart2js to compile more optimal code for key-value pair reads/writes.
@Deprecated('This API is for use only within generated code.'
    ' Do not reference it in your code, as it may change at any time.')
class _$$TestProps$JsMap extends _$$TestProps {
  // This initializer of `_props` to an empty map, as well as the reassignment
  // of `_props` in the constructor body is necessary to work around a DDC bug: https://github.com/dart-lang/sdk/issues/36217
  _$$TestProps$JsMap(JsBackedMap backingMap)
      : this._props = JsBackedMap(),
        super._() {
    this._props = backingMap ?? JsBackedMap();
  }

  /// The backing props map proxied by this class.
  @override
  JsBackedMap get props => _props;
  JsBackedMap _props;
}
